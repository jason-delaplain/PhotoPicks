# PhotoPicks - AI Agent Instructions

## Project Overview
PhotoPicks is a React Native/Expo photo management app with gesture-based organization and AI-powered photo analysis. The app uses a **mode-based architecture** where users select different features from a landing page.

## Critical Architecture Patterns

### Version Compatibility (⚠️ CRITICAL)
- **Expo SDK 52** with **React Native 0.75.4** and **React 18.2.0**
- All Expo packages MUST use `~` for tilde-range versions (e.g., `expo-font: ~12.0.10`)
- Never suggest React 19.x or React Native 0.76+ (incompatible with current Expo setup)
- iOS CocoaPods requires this specific RN version - newer versions break ReactAppDependencyProvider

### MediaCache Singleton Pattern
The app uses an **in-memory shared cache** (`src/utils/mediaCache.ts`) that ALL photo-reading components must use:

```typescript
import { MediaCache } from '@/utils/mediaCache';

// Initial load or when cache is empty
const { photos, resolvedUris } = await MediaCache.getOrScan(progress => setScanningProgress(progress));

// Force refresh (pull-to-refresh scenarios)
const { photos, resolvedUris } = await MediaCache.refresh(progress => setScanningProgress(progress));

// After deletions - keep cache in sync
MediaCache.removeByIds(['photo-id-1', 'photo-id-2']);
```

**Why:** MediaLibrary scanning is expensive (5000+ photos = 30+ seconds). Cache ensures instant navigation between modes.

### iOS URI Resolution Pattern
iOS returns `ph://` asset library URIs that React Native Image cannot display. **Always resolve before rendering:**

```typescript
import resolveMediaUri from '@/utils/resolveMediaUri';

// Lazy resolution in useEffect
const resolvedUri = await resolveMediaUri({ id: photo.id, uri: photo.uri });
setResolvedUris(prev => ({ ...prev, [photo.id]: resolvedUri }));

// Update shared cache
MediaCache.updateResolvedUri(photo.id, resolvedUri);
```

**Pattern:** Components maintain `resolvedUris: Record<string, string>` and resolve current + next photos lazily.

### Mode-Based Navigation
App.tsx uses string-based mode switching (no React Navigation):

```typescript
type AppMode = 'loading' | 'landing' | 'swipe' | 'blurry' | 'duplicates' | 'keyword';
const [mode, setMode] = useState<AppMode>('loading');
```

All screens receive `onBack: () => void` prop that calls `setMode('landing')`. No navigation stack.

### Gesture-Driven UX
- **Swipe Mode**: Pan gestures with threshold-based actions, rotation animations, haptic feedback on threshold crossing
- **Preview Zoom**: Pinch-to-zoom (RNGH PinchGestureHandler) + double-tap toggle (1x ↔ 2x)
- **Edge Swipe**: Left-edge pan gesture (< 24px from left) for iOS-style back navigation

### Permission Handling
**Always request with write access** for deletion support:

```typescript
const { status } = await MediaLibrary.requestPermissionsAsync(true); // true = writeOnly
```

## Development Workflows

### Installing Dependencies
```bash
npm install --legacy-peer-deps  # Required for Expo package resolution
```

### Testing Critical Paths
```bash
npm test                    # Run Jest tests
npm run typecheck          # TypeScript validation (strict mode enabled)
npm run lint               # ESLint checks
```

### Native Builds
```bash
npx expo prebuild --clean  # Regenerate ios/ and android/ folders
npm run ios                # Build and run on iOS
npm run android            # Build and run on Android
```

**Never commit** `ios/` or `android/` folders - they're regenerated by `expo prebuild`.

### Path Aliases
Use `@/*` imports everywhere (configured in babel.config.js and tsconfig.json):

```typescript
import { MediaCache } from '@/utils/mediaCache';
import SwipePhotoSwiper from '@/components/SwipePhotoSwiper';
```

## Code Conventions

### TypeScript Strictness
- `noImplicitAny: true` - all parameters and variables must be explicitly typed
- Props interfaces defined inline or as separate interface declarations
- No `any` types except when interfacing with untyped native modules

### Animation Patterns
Use `useRef` for Animated values to persist across renders:

```typescript
const translateX = useRef(new Animated.Value(0)).current;
const rotation = useRef(new Animated.Value(0)).current;

// Parallel animations for smooth UX
Animated.parallel([
  Animated.timing(translateX, { toValue: 100, duration: 300, useNativeDriver: true }),
  Animated.timing(rotation, { toValue: 30, duration: 300, useNativeDriver: true }),
]).start();
```

**Always use `useNativeDriver: true`** for transform/opacity animations.

### Haptic Feedback Pattern
Wrap in try-catch (not available in Expo Go):

```typescript
try {
  await Haptics.impactAsync(Haptics.ImpactFeedbackStyle.Medium);
} catch {}
```

### Error Handling
- User-facing errors: Use `Alert.alert()` with helpful messages
- Background errors: `console.error()` with context
- Never silent failures - log or show feedback

### Testing Mocks
All Expo modules are mocked in `jest.setup.js`:
- `expo-media-library`: Returns mock assets
- `expo-file-system`: No-op file operations
- `expo-haptics`: Silent success
- `expo-image-manipulator`: Returns mock manipulated images

When adding new Expo module, update jest.setup.js with appropriate mocks.

## Common Pitfalls

❌ **Don't** scan MediaLibrary directly in components - use MediaCache
❌ **Don't** use React Navigation - mode switching is string-based
❌ **Don't** display iOS `ph://` URIs directly - resolve them first
❌ **Don't** forget `--legacy-peer-deps` when installing packages
❌ **Don't** update to React 19 or RN 0.76+ (breaks iOS builds)
❌ **Don't** commit ios/ or android/ folders (generated by expo prebuild)

✅ **Do** use MediaCache for all photo library access
✅ **Do** resolve URIs lazily for current + next photos
✅ **Do** wrap haptics in try-catch
✅ **Do** use path aliases (`@/utils/...`)
✅ **Do** enable native driver for animations
✅ **Do** request write permissions for MediaLibrary

## Key Files Reference

- `src/utils/mediaCache.ts` - Shared photo library cache (singleton pattern)
- `src/utils/resolveMediaUri.ts` - iOS URI resolution helper
- `src/components/SwipePhotoSwiper.tsx` - Reference for gesture handling patterns
- `src/components/BlurryPhotos.tsx` - Reference for image analysis and batch operations
- `jest.setup.js` - Expo module mocks for testing
- `babel.config.js` - Module resolver configuration for path aliases

## Performance Considerations

- **Thumbnail analysis**: Use `ImageManipulator.manipulateAsync` to resize to 256px before processing
- **Lazy loading**: Only resolve URIs for visible + upcoming photos
- **Batch processing**: Process photos in chunks (e.g., 16 at a time) with progress callbacks
- **Animation jank**: Always use `useNativeDriver: true` for transform/opacity
- **Memory**: MediaCache is in-memory only - clears on app restart

## Future-Proofing

When implementing new AI features (duplicates, keyword search, etc.):
1. Create new component in `src/components/`
2. Add mode to `AppMode` union type in App.tsx
3. Use MediaCache for photo access
4. Follow gesture patterns from SwipePhotoSwiper
5. Add onBack handler for landing page navigation
6. Mock dependencies in jest.setup.js for testing

## Questions to Ask Before Implementing

- Does this need real-time photo library access? → Use MediaCache
- Will this work on iOS? → Test URI resolution
- Does this need gestures? → Reference SwipePhotoSwiper patterns
- Is this adding dependencies? → Check Expo SDK 52 compatibility
- Does this animate? → Use useRef + useNativeDriver
